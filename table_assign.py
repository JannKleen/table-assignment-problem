import math

def _get_table_suggestions(tables, num):
    '''
    The table assigment problem is the problem of assigning tables for a
    number of people with the following desirable properties.
      - Avoid having unused seats in tables
      - If several tables are required, they should be near to each other
      - Select isolated tables
        (far from occupied tables, or big unoccupied tables)

    This greedy algorithm finds a solution in polynomial time O(n^3),
    where n is the number of tables.

    Intuitively, the algorithm tries to optimize the aggregate of utilities
    for each person.

    The utility of a person is defined based on the amount of sound that comes
    from seats who can be occupied by her friends (relevant elements) or not.
    We compute the precision (friends sound received over total sound received)
    and recall (friends sound received over total friends sound). The utility is
    the harmonic mean of the above quantities (F-measure). We consider that
    empty seats generate a fraction of the sound generated by an occupied seat,
    this favors choosing more isolated tables.

    The quantity of sound received from one person p1 sitting in table t1 by
    another person p2 sitting in table t2 depends on the distance between this
    two persons. The distance is computed as the Euclidean distance of t1 and t2
    The distance has constant values on the special cases
    (t1 equals t2,
    t1 and t2 belong to different rooms,
    t1 or t2 have no coordinates).

    - The algorithm iteratively selects tables until there is no more people
      to be seated. If possible, the first table selected belongs to a room with
      enough space to seat everybody. In that case, only tables from that room
      are selected in following iterations.
    - At each step the table with highest score is selected.
    - The score is computed as the sum of the score of each seat if the table is
      selected.
    - The score of each seat in the table is computed as the F-measure if the
      seat is occupied. The seat takes a negative constant value if it is not
      occupied.
    '''
    # the utility of an empty seat in an occupied table
    empty_seat_utility = -0.5

    # fraction of noise that an empty seat generates
    # should aproximatelly the probability of the seat being occupied
    # in the near future
    empty_seat_noise_factor = 0.1

    # this simulates amplifying the sound of our friends
    # as we pay more attention to them
    friends_factor = 2

    # constants for special distances
    distance_same_table = 1
    distance_different_rooms = 100.
    distance_unassigned_table = 2.

    # if there exist at least one room with enough space
    # remove all tables that belong to rooms without enough space
    # it forces the algorithm to select all tables in the same room if possible
    roomsize = {}
    for table in tables:
        if table.roomid not in roomsize:
            roomsize[table.roomid] = 0
        roomsize[table.roomid] += table.capacity
    if roomsize and max(roomsize.values()) >= num:
        newtables = []
        for table in tables:
            if roomsize[table.roomid] >= num:
                newtables.append(table)
        tables = newtables

    ret = []
    # if there aren't enough seats do nothing
    if num > sum([table.available for table in tables]):
        return None
    toseat = num
    # while there is still people to seat
    while toseat > 0:
        maxtable = None
        maxutility = float('-inf')
        # calculate the score (utility) of each table and select
        # the one with the highest score
        for table in tables:
            if table.available:
                friends_sound_received = 0
                total_sound_received = 0
                empty_seats = 0
                ppl1 = table.capacity
                if toseat < table.capacity:
                    ppl1 = toseat
                    empty_seats = table.capacity-toseat
                # iterate all tables to calculate the sound coming from them
                for table2 in tables:
                    # get the distance between table and table2
                    if table.id == table2.id:
                        d = distance_same_table
                    elif table.roomid != table2.roomid:
                        d = distance_different_rooms
                    elif table.unassigned or table2.unassigned:
                        d = distance_unassigned_table
                    else:
                        d = math.sqrt(
                            math.pow(
                                table.table_location_horizontal -
                                table2.table_location_horizontal, 2) +
                            math.pow(table.table_location_vertical -
                                     table2.table_location_vertical, 2))
                    if d == 0:
                        d = distance_same_table

                    # check if the people in table and table2 are friends
                    # that is, they come from the same booking
                    friends = False
                    if table.id == table2.id:
                        friends = True
                    else:
                        for r in ret:
                            if r.id == table2.id:
                                friends = True

                    # get the number of people (more people, more noise)
                    # empty seats also generate noise
                    # (a fraction of a filled seat)
                    # the fraction should be roughly the probability of the seat
                    # to be filled in the near future.
                    # variable empty_seat_noise_factor
                    ppl2 = table2.capacity
                    if table2.available:
                        ppl2 = table2.capacity*empty_seat_noise_factor
                    # calculate the sound generated, which is proportional
                    # to the number of people and inverselly proportional
                    # to the distance
                    sound = ppl2/d
                    # if the people are friends, amplify the sounds
                    # because we pay more attention to our friends
                    # than to strangers
                    if friends:
                        sound = sound * friends_factor

                    # aggregate the amount of sound into total_sound_received
                    # and friends_sound_received
                    total_sound_received += sound
                    if friends:
                        friends_sound_received += sound
                unseated_ppl = toseat - table.capacity
                if unseated_ppl < 0:
                    unseated_ppl = 0

                # precision is a measure of how much sound over the total sound
                # received comes from our friends. we want to maximize this.
                precision = friends_sound_received/total_sound_received

                # precision alone is not enough. e.g., separating a group
                # in different empty rooms would have maximum precision. we need
                # to maximize recall as well. it is defined as the fraction of
                # sound that we receive from our friends over the total
                # amount of sound generated by them.
                recall = ppl1*friends_sound_received/num

                # the utility function or score is the harmonic mean of
                # precision and recall.
                F = 2*precision*recall/(precision+recall)
                utility = ppl1*F + empty_seats*empty_seat_utility

                # select the table with max utility
                if utility > maxutility:
                    maxutility = utility
                    maxtable = table
        if maxtable:
            # if the room of the first selected table fits everybody
            # choose only tables from the same room
            # we force this by removing all the tables belonging
            # to other rooms in the list of tables
            if len(ret) == 0 and roomsize[maxtable.roomid] >= num:
                newtables = []
                for table in tables:
                    if table.roomid == maxtable.roomid:
                        newtables.append(table)
                tables = newtables

            # add the table with maximum score to the solution
            # mark it as not available and update the number of people
            # to be seated
            ret.append(maxtable)
            maxtable.available = 0
            toseat -= maxtable.capacity
    return ret
